/*
Holodex/HoloAPI V2

Holodex Public API. Successor to the HoloAPI v1

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package holodex

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiGetCachedLiveRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	channels *string
}

// comma separated Youtube Channel IDs
func (r ApiGetCachedLiveRequest) Channels(channels string) ApiGetCachedLiveRequest {
	r.channels = &channels
	return r
}

func (r ApiGetCachedLiveRequest) Execute() ([]Video, *http.Response, error) {
	return r.ApiService.GetCachedLiveExecute(r)
}

/*
GetCachedLive Quickly Access Live / Upcoming for a set of Channels

This endpoint is similar to the /live endpoint and usually replies much faster. It is more friendly in general. The cost to execute a lookup is significantly cheaper. It's unfortunately less customizable as a result.

We recommends using this if you have a fixed set of channel IDs to look up status for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCachedLiveRequest
*/
func (a *DefaultApiService) GetCachedLive(ctx context.Context) ApiGetCachedLiveRequest {
	return ApiGetCachedLiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Video
func (a *DefaultApiService) GetCachedLiveExecute(r ApiGetCachedLiveRequest) ([]Video, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Video
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCachedLive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/live"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channels != nil {
		localVarQueryParams.Add("channels", parameterToString(*r.channels, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	type_ *string
	offset *int32
	limit *int32
	org *string
	lang *string
	sort *string
	order *string
}

// Type of Channel, whether it&#39;s a vtuber or a subber. Leave unset to query all. 
func (r ApiGetChannelsRequest) Type_(type_ string) ApiGetChannelsRequest {
	r.type_ = &type_
	return r
}

// Offset results
func (r ApiGetChannelsRequest) Offset(offset int32) ApiGetChannelsRequest {
	r.offset = &offset
	return r
}

// Results limit
func (r ApiGetChannelsRequest) Limit(limit int32) ApiGetChannelsRequest {
	r.limit = &limit
	return r
}

// If set, filter for Vtuber belonging to a specific org
func (r ApiGetChannelsRequest) Org(org string) ApiGetChannelsRequest {
	r.org = &org
	return r
}

// Comma separated list of languages. Language is a property of Channel, so only Channels satisfying the language will be returned. Leave empty to search for Vtubers and/or all clippers.
func (r ApiGetChannelsRequest) Lang(lang string) ApiGetChannelsRequest {
	r.lang = &lang
	return r
}

// Column to sort on, leave default to use &#39;org&#39; as sort. Any first level property of channel should work here.
func (r ApiGetChannelsRequest) Sort(sort string) ApiGetChannelsRequest {
	r.sort = &sort
	return r
}

// ASC or DESC order, default asc.
func (r ApiGetChannelsRequest) Order(order string) ApiGetChannelsRequest {
	r.order = &order
	return r
}

func (r ApiGetChannelsRequest) Execute() ([]Channel, *http.Response, error) {
	return r.ApiService.GetChannelsExecute(r)
}

/*
GetChannels List Channels



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelsRequest
*/
func (a *DefaultApiService) GetChannels(ctx context.Context) ApiGetChannelsRequest {
	return ApiGetChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Channel
func (a *DefaultApiService) GetChannelsExecute(r ApiGetChannelsRequest) ([]Channel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Channel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.org != nil {
		localVarQueryParams.Add("org", parameterToString(*r.org, ""))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetV2ChannelsChannelIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	channelId string
}

func (r ApiGetV2ChannelsChannelIdRequest) Execute() (*Channel, *http.Response, error) {
	return r.ApiService.GetV2ChannelsChannelIdExecute(r)
}

/*
GetV2ChannelsChannelId Get Channel Information



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId ID of the Youtube Channel that is being queried
 @return ApiGetV2ChannelsChannelIdRequest
*/
func (a *DefaultApiService) GetV2ChannelsChannelId(ctx context.Context, channelId string) ApiGetV2ChannelsChannelIdRequest {
	return ApiGetV2ChannelsChannelIdRequest{
		ApiService: a,
		ctx: ctx,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return Channel
func (a *DefaultApiService) GetV2ChannelsChannelIdExecute(r ApiGetV2ChannelsChannelIdRequest) (*Channel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Channel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetV2ChannelsChannelId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetV2ChannelsChannelIdClipsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	channelId string
	type_ string
	lang *string
	include *[]string
	limit *int32
	offset *int32
	paginated *string
}

// A comma separated list of language codes to filter channels/clips, official streams do not follow this parameter
func (r ApiGetV2ChannelsChannelIdClipsRequest) Lang(lang string) ApiGetV2ChannelsChannelIdClipsRequest {
	r.lang = &lang
	return r
}

// Comma separated string of extra info for video. Should be a string instead of an array.
func (r ApiGetV2ChannelsChannelIdClipsRequest) Include(include []string) ApiGetV2ChannelsChannelIdClipsRequest {
	r.include = &include
	return r
}

// Results limit
func (r ApiGetV2ChannelsChannelIdClipsRequest) Limit(limit int32) ApiGetV2ChannelsChannelIdClipsRequest {
	r.limit = &limit
	return r
}

// Offset results
func (r ApiGetV2ChannelsChannelIdClipsRequest) Offset(offset int32) ApiGetV2ChannelsChannelIdClipsRequest {
	r.offset = &offset
	return r
}

// If paginated is set to any non-empty value, return an object with total, otherwise returns an array.
func (r ApiGetV2ChannelsChannelIdClipsRequest) Paginated(paginated string) ApiGetV2ChannelsChannelIdClipsRequest {
	r.paginated = &paginated
	return r
}

func (r ApiGetV2ChannelsChannelIdClipsRequest) Execute() (*GetV2ChannelsChannelIdClips200Response, *http.Response, error) {
	return r.ApiService.GetV2ChannelsChannelIdClipsExecute(r)
}

/*
GetV2ChannelsChannelIdClips Query Videos Related to Channel

A simplified endpoint for access channel specific data. If you want more customization, the same result can be obtained by calling the `/videos` endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId ID of the Youtube Channel that is being queried
 @param type_ The type of video resource to fetch. Clips finds clip videos of a `vtuber` channel, Video finds the `channelId` channel's uploads, and collabs finds videos uploaded by other channels that mention this `channelId`
 @return ApiGetV2ChannelsChannelIdClipsRequest
*/
func (a *DefaultApiService) GetV2ChannelsChannelIdClips(ctx context.Context, channelId string, type_ string) ApiGetV2ChannelsChannelIdClipsRequest {
	return ApiGetV2ChannelsChannelIdClipsRequest{
		ApiService: a,
		ctx: ctx,
		channelId: channelId,
		type_: type_,
	}
}

// Execute executes the request
//  @return GetV2ChannelsChannelIdClips200Response
func (a *DefaultApiService) GetV2ChannelsChannelIdClipsExecute(r ApiGetV2ChannelsChannelIdClipsRequest) (*GetV2ChannelsChannelIdClips200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetV2ChannelsChannelIdClips200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetV2ChannelsChannelIdClips")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelId}/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterToString(r.type_, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.paginated != nil {
		localVarQueryParams.Add("paginated", parameterToString(*r.paginated, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVideosVideoIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	videoId string
	lang *string
	c *string
}

// A comma separated list of language codes to filter channels/clips, official streams do not follow this parameter
func (r ApiGetVideosVideoIdRequest) Lang(lang string) ApiGetVideosVideoIdRequest {
	r.lang = &lang
	return r
}

// if &#x60;1&#x60; then will reply with timestamp comments for this video
func (r ApiGetVideosVideoIdRequest) C(c string) ApiGetVideosVideoIdRequest {
	r.c = &c
	return r
}

func (r ApiGetVideosVideoIdRequest) Execute() (*GetVideosVideoId200Response, *http.Response, error) {
	return r.ApiService.GetVideosVideoIdExecute(r)
}

/*
GetVideosVideoId Get a single Video's metadata

Retrieves a video object.

Also retrieves Comments if query parameter `c` is set.

Also retrieves Recommendations if query parameter `lang` is set

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param videoId ID of a Youtube Video
 @return ApiGetVideosVideoIdRequest
*/
func (a *DefaultApiService) GetVideosVideoId(ctx context.Context, videoId string) ApiGetVideosVideoIdRequest {
	return ApiGetVideosVideoIdRequest{
		ApiService: a,
		ctx: ctx,
		videoId: videoId,
	}
}

// Execute executes the request
//  @return GetVideosVideoId200Response
func (a *DefaultApiService) GetVideosVideoIdExecute(r ApiGetVideosVideoIdRequest) (*GetVideosVideoId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVideosVideoId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVideosVideoId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/videos/{videoId}"
	localVarPath = strings.Replace(localVarPath, "{"+"videoId"+"}", url.PathEscape(parameterToString(r.videoId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, ""))
	}
	if r.c != nil {
		localVarQueryParams.Add("c", parameterToString(*r.c, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	channelId *string
	status *string
	lang *string
	type_ *string
	topic *string
	include *[]string
	org *string
	mentionedChannelId *string
	sort *string
	order *string
	limit *int32
	offset *int32
	paginated *string
	maxUpcomingHours *float32
	id *string
}

// Filter by video uploader channel id
func (r ApiLiveGetRequest) ChannelId(channelId string) ApiLiveGetRequest {
	r.channelId = &channelId
	return r
}

// Filter by video status
func (r ApiLiveGetRequest) Status(status string) ApiLiveGetRequest {
	r.status = &status
	return r
}

// A comma separated list of language codes to filter channels/clips, official streams do not follow this parameter
func (r ApiLiveGetRequest) Lang(lang string) ApiLiveGetRequest {
	r.lang = &lang
	return r
}

// Filter by type of video
func (r ApiLiveGetRequest) Type_(type_ string) ApiLiveGetRequest {
	r.type_ = &type_
	return r
}

// Filter by video topic id
func (r ApiLiveGetRequest) Topic(topic string) ApiLiveGetRequest {
	r.topic = &topic
	return r
}

// Comma separated string of extra info for video. Should be a string instead of an array.
func (r ApiLiveGetRequest) Include(include []string) ApiLiveGetRequest {
	r.include = &include
	return r
}

// Filter by clips that feature the org&#39;s talent or videos posted by the org&#39;s talent
func (r ApiLiveGetRequest) Org(org string) ApiLiveGetRequest {
	r.org = &org
	return r
}

// Filter by mentioned channel id, excludes itself. Generally used to find collabs/clips that include the requested channel
func (r ApiLiveGetRequest) MentionedChannelId(mentionedChannelId string) ApiLiveGetRequest {
	r.mentionedChannelId = &mentionedChannelId
	return r
}

// Sort by any returned video field
func (r ApiLiveGetRequest) Sort(sort string) ApiLiveGetRequest {
	r.sort = &sort
	return r
}

// Order by ascending or descending
func (r ApiLiveGetRequest) Order(order string) ApiLiveGetRequest {
	r.order = &order
	return r
}

// Results limit
func (r ApiLiveGetRequest) Limit(limit int32) ApiLiveGetRequest {
	r.limit = &limit
	return r
}

// Offset results
func (r ApiLiveGetRequest) Offset(offset int32) ApiLiveGetRequest {
	r.offset = &offset
	return r
}

// If paginated is set to any non-empty value, return an object with total, otherwise returns an array.
func (r ApiLiveGetRequest) Paginated(paginated string) ApiLiveGetRequest {
	r.paginated = &paginated
	return r
}

// Number of maximum hours upcoming to get upcoming videos by (for rejecting waiting rooms that are two years out)
func (r ApiLiveGetRequest) MaxUpcomingHours(maxUpcomingHours float32) ApiLiveGetRequest {
	r.maxUpcomingHours = &maxUpcomingHours
	return r
}

// A single Youtube Video ID. If Specified, only this video can be returned (may be filtered out by other conditions though)
func (r ApiLiveGetRequest) Id(id string) ApiLiveGetRequest {
	r.id = &id
	return r
}

func (r ApiLiveGetRequest) Execute() (*LiveGet200Response, *http.Response, error) {
	return r.ApiService.LiveGetExecute(r)
}

/*
LiveGet Query Live and Upcoming Videos

This is somewhat similar to calling `/videos`. 

However, this endpoint imposes these default values on the query parameters: You can choose to override them by providing your own values.
  
    status: [STATUSES.LIVE, STATUSES.UPCOMING].join(','),
    type: 'stream',
    sort: 'available_at',
    order: 'asc',
    max_upcoming_hours: 48,
    limit: 9999,
    include: live_info + query's include
  

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveGetRequest
*/
func (a *DefaultApiService) LiveGet(ctx context.Context) ApiLiveGetRequest {
	return ApiLiveGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LiveGet200Response
func (a *DefaultApiService) LiveGetExecute(r ApiLiveGetRequest) (*LiveGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.LiveGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/live"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		localVarQueryParams.Add("channel_id", parameterToString(*r.channelId, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.topic != nil {
		localVarQueryParams.Add("topic", parameterToString(*r.topic, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.org != nil {
		localVarQueryParams.Add("org", parameterToString(*r.org, ""))
	}
	if r.mentionedChannelId != nil {
		localVarQueryParams.Add("mentioned_channel_id", parameterToString(*r.mentionedChannelId, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.paginated != nil {
		localVarQueryParams.Add("paginated", parameterToString(*r.paginated, ""))
	}
	if r.maxUpcomingHours != nil {
		localVarQueryParams.Add("max_upcoming_hours", parameterToString(*r.maxUpcomingHours, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSearchCommentSearchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	postSearchCommentSearchRequest *PostSearchCommentSearchRequest
}

// 
func (r ApiPostSearchCommentSearchRequest) PostSearchCommentSearchRequest(postSearchCommentSearchRequest PostSearchCommentSearchRequest) ApiPostSearchCommentSearchRequest {
	r.postSearchCommentSearchRequest = &postSearchCommentSearchRequest
	return r
}

func (r ApiPostSearchCommentSearchRequest) Execute() (*PostSearchCommentSearch200Response, *http.Response, error) {
	return r.ApiService.PostSearchCommentSearchExecute(r)
}

/*
PostSearchCommentSearch 

Flexible endpoint to search for comments in videos fufilling multiple conditions. Descriptions with "any" implies an OR condition, and "all" implies a AND condition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSearchCommentSearchRequest
*/
func (a *DefaultApiService) PostSearchCommentSearch(ctx context.Context) ApiPostSearchCommentSearchRequest {
	return ApiPostSearchCommentSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostSearchCommentSearch200Response
func (a *DefaultApiService) PostSearchCommentSearchExecute(r ApiPostSearchCommentSearchRequest) (*PostSearchCommentSearch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostSearchCommentSearch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PostSearchCommentSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search/commentSearch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postSearchCommentSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSearchVideoSearchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	postSearchVideoSearchRequest *PostSearchVideoSearchRequest
}

// 
func (r ApiPostSearchVideoSearchRequest) PostSearchVideoSearchRequest(postSearchVideoSearchRequest PostSearchVideoSearchRequest) ApiPostSearchVideoSearchRequest {
	r.postSearchVideoSearchRequest = &postSearchVideoSearchRequest
	return r
}

func (r ApiPostSearchVideoSearchRequest) Execute() (*PostSearchVideoSearch200Response, *http.Response, error) {
	return r.ApiService.PostSearchVideoSearchExecute(r)
}

/*
PostSearchVideoSearch 

Flexible endpoint to search for videos fufilling multiple conditions. Descriptions with "any" implies an OR condition, and "all" implies a AND condition.

Searching for topics and clips is not supported, because clips do not contain topic_ids 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSearchVideoSearchRequest
*/
func (a *DefaultApiService) PostSearchVideoSearch(ctx context.Context) ApiPostSearchVideoSearchRequest {
	return ApiPostSearchVideoSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostSearchVideoSearch200Response
func (a *DefaultApiService) PostSearchVideoSearchExecute(r ApiPostSearchVideoSearchRequest) (*PostSearchVideoSearch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostSearchVideoSearch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PostSearchVideoSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search/videoSearch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postSearchVideoSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVideosGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	channelId *string
	status *string
	lang *string
	type_ *string
	topic *string
	include *[]string
	org *string
	mentionedChannelId *string
	sort *string
	order *string
	limit *int32
	offset *int32
	paginated *string
	maxUpcomingHours *float32
	id *string
	from *string
	to *string
}

// Filter by video uploader channel id
func (r ApiVideosGetRequest) ChannelId(channelId string) ApiVideosGetRequest {
	r.channelId = &channelId
	return r
}

// Filter by video status
func (r ApiVideosGetRequest) Status(status string) ApiVideosGetRequest {
	r.status = &status
	return r
}

// A comma separated list of language codes to filter channels/clips, official streams do not follow this parameter
func (r ApiVideosGetRequest) Lang(lang string) ApiVideosGetRequest {
	r.lang = &lang
	return r
}

// Filter by type of video
func (r ApiVideosGetRequest) Type_(type_ string) ApiVideosGetRequest {
	r.type_ = &type_
	return r
}

// Filter by video topic id
func (r ApiVideosGetRequest) Topic(topic string) ApiVideosGetRequest {
	r.topic = &topic
	return r
}

// Comma separated string of extra info for video. Should be a string instead of an array.
func (r ApiVideosGetRequest) Include(include []string) ApiVideosGetRequest {
	r.include = &include
	return r
}

// Filter by clips that feature the org&#39;s talent or videos posted by the org&#39;s talent
func (r ApiVideosGetRequest) Org(org string) ApiVideosGetRequest {
	r.org = &org
	return r
}

// Filter by mentioned channel id, excludes itself. Generally used to find collabs/clips that include the requested channel
func (r ApiVideosGetRequest) MentionedChannelId(mentionedChannelId string) ApiVideosGetRequest {
	r.mentionedChannelId = &mentionedChannelId
	return r
}

// Sort by any returned video field
func (r ApiVideosGetRequest) Sort(sort string) ApiVideosGetRequest {
	r.sort = &sort
	return r
}

// Order by ascending or descending
func (r ApiVideosGetRequest) Order(order string) ApiVideosGetRequest {
	r.order = &order
	return r
}

// Results limit
func (r ApiVideosGetRequest) Limit(limit int32) ApiVideosGetRequest {
	r.limit = &limit
	return r
}

// Offset results
func (r ApiVideosGetRequest) Offset(offset int32) ApiVideosGetRequest {
	r.offset = &offset
	return r
}

// If paginated is set to any non-empty value, return an object with total, otherwise returns an array.
func (r ApiVideosGetRequest) Paginated(paginated string) ApiVideosGetRequest {
	r.paginated = &paginated
	return r
}

// Number of maximum hours upcoming to get upcoming videos by (for rejecting waiting rooms that are two years out)
func (r ApiVideosGetRequest) MaxUpcomingHours(maxUpcomingHours float32) ApiVideosGetRequest {
	r.maxUpcomingHours = &maxUpcomingHours
	return r
}

// A single Youtube Video ID. If Specified, only this video can be returned (may be filtered out by other conditions though)
func (r ApiVideosGetRequest) Id(id string) ApiVideosGetRequest {
	r.id = &id
	return r
}

// ISO8601 Date String for minimum &#x60;available_at&#x60;. (&#x60;available_at&#x60; is the most accurate timestamp of when a video has gone live or became viewable - it is the first non null value of the &#x60;start_actual&#x60;, &#x60;start_scheduled&#x60; or &#x60;published_at&#x60; fields)
func (r ApiVideosGetRequest) From(from string) ApiVideosGetRequest {
	r.from = &from
	return r
}

// ISO8601 Date String for maximum &#x60;available_at&#x60;
func (r ApiVideosGetRequest) To(to string) ApiVideosGetRequest {
	r.to = &to
	return r
}

func (r ApiVideosGetRequest) Execute() (*VideoFull, *http.Response, error) {
	return r.ApiService.VideosGetExecute(r)
}

/*
VideosGet Query Videos

Pretty much everything you need. This is the most 'vanilla' variant with almost no preset values, and `/channels/{channelId}/{type}` and `/live` endpoints both use the same query structure but provision default values differently for some of the query params.

Not as powerful at searching arbitrary text as the Search API (currently not documented/available). 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVideosGetRequest
*/
func (a *DefaultApiService) VideosGet(ctx context.Context) ApiVideosGetRequest {
	return ApiVideosGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VideoFull
func (a *DefaultApiService) VideosGetExecute(r ApiVideosGetRequest) (*VideoFull, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VideoFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VideosGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/videos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		localVarQueryParams.Add("channel_id", parameterToString(*r.channelId, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.topic != nil {
		localVarQueryParams.Add("topic", parameterToString(*r.topic, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.org != nil {
		localVarQueryParams.Add("org", parameterToString(*r.org, ""))
	}
	if r.mentionedChannelId != nil {
		localVarQueryParams.Add("mentioned_channel_id", parameterToString(*r.mentionedChannelId, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.paginated != nil {
		localVarQueryParams.Add("paginated", parameterToString(*r.paginated, ""))
	}
	if r.maxUpcomingHours != nil {
		localVarQueryParams.Add("max_upcoming_hours", parameterToString(*r.maxUpcomingHours, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.from != nil {
		localVarQueryParams.Add("from", parameterToString(*r.from, ""))
	}
	if r.to != nil {
		localVarQueryParams.Add("to", parameterToString(*r.to, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
